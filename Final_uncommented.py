"""Mitochondria_segmentation_with_UNet.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1glNGdnG6LOm6ByQ6R_WEo9_FJ-_N6lQA
"""

# -*- coding: utf-8 -*-
"""
Created on Fri Mar  5 16:40:21 2021
@author: KoppÃ¡ny
"""
import tensorflow as tf
from tensorflow import keras
#from google.colab import drive

from keras.utils import normalize
import cv2
import numpy as np
from matplotlib import pyplot as plt

from keras.models import Model
from keras.layers import Input, Conv2D, MaxPooling2D, UpSampling2D, concatenate, Conv2DTranspose, BatchNormalization, Dropout, Lambda

from sklearn.model_selection import train_test_split #splitting the pictures into training and testing sets
import random
import numpy as np

from keras.optimizers import Adam
from keras.callbacks import EarlyStopping, ModelCheckpoint

from tkinter import *

from PIL import ImageTk, Image
import os

from tkinter import ttk, colorchooser
from PIL import ImageGrab, ImageTk, Image, ImageDraw
import copy


############################# CODE

class MithocondriaSegmenter:

    def __init__(self):
        self.TrainingImages = []
        self.TrainingMasks = []
        self.imgsize = -1
        self.model = None

        self.__X_train = None
        self.__X_test = None
        self.__y_train = None
        self.__y_test = None

    # a simple unet model, nothing special, i don't think that it is absolutely required to be able to write it, 'cause so many others already did it
    def __unet(self, img_height, img_width, img_channels):
        inputs = Input((img_height, img_width, img_channels))

        s = inputs

        # Contraction path
        c1 = Conv2D(16, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(s)
        c1 = Dropout(0.1)(c1)
        c1 = Conv2D(16, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c1)
        p1 = MaxPooling2D((2, 2))(c1)

        c2 = Conv2D(32, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(p1)
        c2 = Dropout(0.1)(c2)
        c2 = Conv2D(32, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c2)
        p2 = MaxPooling2D((2, 2))(c2)

        c3 = Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(p2)
        c3 = Dropout(0.2)(c3)
        c3 = Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c3)
        p3 = MaxPooling2D((2, 2))(c3)

        c4 = Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(p3)
        c4 = Dropout(0.2)(c4)
        c4 = Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c4)
        p4 = MaxPooling2D(pool_size=(2, 2))(c4)

        c5 = Conv2D(256, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(p4)
        c5 = Dropout(0.3)(c5)
        c5 = Conv2D(256, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c5)

        # Expansive path
        u6 = Conv2DTranspose(128, (2, 2), strides=(2, 2), padding='same')(c5)
        u6 = concatenate([u6,
                          c4])  # concatenation is between certain layers of the contraction and expansion paths, it transfers data from one end to the other end
        c6 = Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(u6)
        c6 = Dropout(0.2)(c6)
        c6 = Conv2D(128, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c6)

        u7 = Conv2DTranspose(64, (2, 2), strides=(2, 2), padding='same')(c6)
        u7 = concatenate([u7, c3])
        c7 = Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(u7)
        c7 = Dropout(0.2)(c7)
        c7 = Conv2D(64, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c7)

        u8 = Conv2DTranspose(32, (2, 2), strides=(2, 2), padding='same')(c7)
        u8 = concatenate([u8, c2])
        c8 = Conv2D(32, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(u8)
        c8 = Dropout(0.1)(c8)
        c8 = Conv2D(32, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c8)

        u9 = Conv2DTranspose(16, (2, 2), strides=(2, 2), padding='same')(c8)
        u9 = concatenate([u9, c1], axis=3)
        c9 = Conv2D(16, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(u9)
        c9 = Dropout(0.1)(c9)
        c9 = Conv2D(16, (3, 3), activation='relu', kernel_initializer='he_normal', padding='same')(c9)

        outputs = Conv2D(1, (1, 1), activation='sigmoid')(c9)  #

        model = Model(inputs=[inputs], outputs=[outputs])
        model.compile(optimizer='adam', loss='binary_crossentropy',
                      metrics=['accuracy'])  # the adam optimizer is the best, but the loss function
        # can be many other, and all of them will alter the result in some way
        model.summary()  # nothin essential, it just give us the whole unet structure back to check whether there are any mistakes

        return model

    def LoadTrainingData(self, image_directory, mask_directory, imgsize=256, limit=None):
        self.imgsize = imgsize
        images = os.listdir(image_directory)  # reading the pictures
        for i, image_name in enumerate(
                images):  # enumerate method adds a counter and returns the enumerate object, so quite usable in our case
            if (image_name.split('.')[1] == 'tif'):  # all the pictures have .tif format. I split the names
                print(image_directory + image_name)
                image = cv2.imread(image_directory + image_name, 0)  # image_directory is defined in the previous block
                image = Image.fromarray(image)  # i turn the images into PIL objects
                #image = Image.open(image_directory + image_name)
                image = image.resize(
                    (self.imgsize, self.imgsize))  # resizing them, because originally they are not 256x256
                self.TrainingImages.append(np.array(
                    image))  # converting them into numpy array, and adding them to our list - the whole thing starts over until
                # the last picture isn't in the list
                if limit != None and i >= limit:
                    break

        masks = os.listdir(mask_directory)  # same thing with the masks as with the pictures
        for i, image_name in enumerate(masks):
            if (image_name.split('.')[1] == 'tif'):
                image = cv2.imread(mask_directory + image_name, 0)
                image = Image.fromarray(image)
                #image = Image.open(mask_directory + image_name)
                image = image.resize((self.imgsize, self.imgsize))
                self.TrainingMasks.append(np.array(image))
                if limit != None and i >= limit:
                    break

        # normalizing images, everybody does that, it's a basic thing in neuronal networks
        self.TrainingImages = np.expand_dims(normalize(np.array(self.TrainingImages), axis=1), 3)
        # not normalizing masks, just rescaling to 0 to 1, because the are already black or white
        self.TrainingMasks = np.expand_dims((np.array(self.TrainingMasks)),
                                            3) / 255.  # /255 is optional, but with that the list will contain only zeros or ones

    def ShowRandomSamplePair(self):
        image_number = random.randint(0, len(self.__X_train))
        plt.figure(figsize=(12, 6))
        plt.subplot(121)
        plt.imshow(np.reshape(self.__X_train[image_number], (256, 256)), cmap='gray')
        plt.subplot(122)
        plt.imshow(np.reshape(self.__y_train[image_number], (256, 256)), cmap='gray')
        plt.show()

    def SetupUnet(self, test_size=0.1, random_state=0):
        # i have left only the 10% of the pictures for testing
        self.__X_train, self.__X_test, self.__y_train, self.__y_test = train_test_split(
            self.TrainingImages,
            self.TrainingMasks,
            test_size=test_size,
            random_state=random_state)

        # checking on a few pictures whether the real images correspond with the masks
        # image_number = random.randint(0, len(X_train))
        # plt.figure(figsize=(12, 6))
        # plt.subplot(121)
        # plt.imshow(np.reshape(X_train[image_number], (256, 256)), cmap='gray')
        # plt.subplot(122)
        # plt.imshow(np.reshape(y_train[image_number], (256, 256)), cmap='gray')
        # plt.show()

        IMG_HEIGHT = self.TrainingImages.shape[1]
        IMG_WIDTH = self.TrainingImages.shape[2]
        IMG_CHANNELS = self.TrainingImages.shape[3]

        self.model = self.__unet(IMG_HEIGHT, IMG_WIDTH, IMG_CHANNELS)

    def SimpleTrainUnet(self, batch_size=5, verbose=1, epochs=10):
        history = self.model.fit(self.__X_train, self.__y_train,
                            # training, for 10 epochs, whit the batch size of 5. There are other options as well, i used these.
                            batch_size=batch_size,
                            verbose=verbose,
                            epochs=epochs,
                            # so with these numbers the training took more, than half an our, so if we want better results, we need more epochs
                            validation_data=(self.__X_test, self.__y_test),
                            shuffle=False)

    def SaveUnetWeights(self, directory):
        self.model.save(
            directory)  # at the end of each epochs, the best results will be saved into this file, and with that we can predict later

    def CheckpointTrainUnetADAM(self, directory):
        self.model.compile(optimizer=Adam(lr=1e-4), loss='binary_crossentropy', metrics=['accuracy'])
        self.model.save(
            directory)  # at the end of each epochs, the best results will be saved into this file, and with that we can predict later

        checkpointer = ModelCheckpoint('model.h5', verbose=1, mode='auto', monitor='loss', save_best_only=True)

        def generate_inputs(X, Y):
            for i in range(len(X)):
                X_input = X[i].reshape(1, 500, 500, 3)
                Y_input = Y[i].reshape(1, 500, 500, 3)
                yield (X_input, Y_input)  # mivel Python generator, ezÃ©rt return helyett yieldet hasznÃ¡lok

        self.model.fit_generator(generate_inputs(self.TrainingImages, self.TrainingMasks), epochs=40, verbose=1,
                            callbacks=[checkpointer],
                            steps_per_epoch=5, shuffle=True)

    def LoadUnetWeights(self, directory):
        self.model.load_weights(directory)  # Trained for 10 epochs

    def PredictResult(self, test_img):
        # every pixel under 0.2 is 0, the other is 1 -> if i write a lower number, the result will be approx. the same, which
        # is very good, because it means, that the network learned pretty well only during 10 epochs
        # altough it is not perfect, of course, so we can use our pattern-recognizing brain to help ot out :)
        test_img_input = np.expand_dims(test_img, 0)
        return (self.model.predict(test_img_input)[0, :, :, 0] > 0.2).astype(np.uint8)


##############################################################################

class ImageViewer(Frame):
    def __init__(self, master, TrainingImageDirectory, TrainingMaskDirectory, UnetWeights50, RawDataPath, ImgSize=256):

        self.TrainingImageDirectory = TrainingImageDirectory
        self.TrainingMaskDirectory = TrainingMaskDirectory

        self.MSegmenter = MithocondriaSegmenter()
        self.MSegmenter.LoadTrainingData(TrainingImageDirectory, TrainingMaskDirectory, imgsize=ImgSize, limit=5)
        self.MSegmenter.SetupUnet()
        self.MSegmenter.LoadUnetWeights(UnetWeights50)

        self.ImageNames = []
        self.RawImages = []
        self.ImgSize=ImgSize

        self.LoadRawData(RawDataPath)
        self.CurrentInput = self.RawImages[0]
        self.CurrentPrediction = self.__ApplyTransformation(self.RawImages[0])
        self.CurrentPredictionOnInput = self.__MaskOnImage(self.RawImages[0], self.CurrentPrediction)
        self.ImCurrentInput = Image.fromarray(self.CurrentInput)
        self.ImCurrentPrediction = Image.fromarray(self.CurrentPrediction)
        self.ImCurrentPredictionOnInput = Image.fromarray(self.CurrentPredictionOnInput)
        self.TKCurrentInput = ImageTk.PhotoImage(Image.fromarray(self.CurrentInput))
        self.TKCurrentPrediction = ImageTk.PhotoImage(Image.fromarray(self.CurrentPrediction))
        self.TKCurrentPredictionOnInput = ImageTk.PhotoImage(Image.fromarray(self.CurrentPredictionOnInput))
        self.ImageCounter = 0

        self.master = master
        master.title("Image Viewer")
        master.geometry("1000x400")

        self.ButtonBack = Button(master, command=self.ButtonBackClick, text="Back")
        self.ButtonExit = Button(master, command=master.quit, text="Exit")
        self.ButtonForward = Button(master, command=self.ButtonForwardClick, text="Forward")
        self.ButtonPainter = Button(master, command=self.CallPainter, text="Modify label")

        self.ButtonBack.grid(row=5, column=1)
        self.ButtonExit.grid(row=5, column=5)
        self.ButtonForward.grid(row=5, column=2)
        self.ButtonPainter.grid(row=5,column=6)

        self.canvas1 = Canvas(master, width=350, height=350)
        self.canvas1.grid(row=1, column=1, columnspan=3)
        self.canvas2 = Canvas(master, width=350, height=350)
        self.canvas2.grid(row=1, column=4, columnspan=3)
        self.canvas3 = Canvas(master, width=350, height=350)
        self.canvas3.grid(row=1, column=7, columnspan=3)

        self.canvas1.create_image(20, 20, anchor="nw", image=self.TKCurrentInput)
        self.canvas2.create_image(20, 20, anchor="nw", image=self.TKCurrentPrediction)
        self.canvas3.create_image(20, 20, anchor="nw", image=self.TKCurrentPredictionOnInput)


    def LoadRawData(self, DataPath):
        DataPath.replace("/", "\\")
        self.ImageNames = os.listdir(DataPath)
        for ImageName in self.ImageNames:
            print(ImageName)
            grayImage = cv2.imread(DataPath + ImageName, 0)
            grayImage = Image.fromarray(grayImage)
            grayImage = grayImage.resize((self.ImgSize, self.ImgSize))
            self.RawImages.append(np.array(grayImage))

    def __ApplyTransformation(self, img):
        Result =  self.MSegmenter.PredictResult(normalize(img))*255
        rgbResult = cv2.cvtColor(Result, cv2.COLOR_GRAY2RGB)
        return rgbResult

    def __MaskOnImage(self, img, mask):
        img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)
        if np.shape(mask)[2] == 3:
            mask = cv2.cvtColor(mask, cv2.COLOR_RGB2GRAY)
        result = np.zeros_like(img, dtype=np.int16)
        result[:,:,0] = img[:,:,0]
        result[:,:,1] = img[:,:,1]-mask/256*50
        result[:,:,2] = img[:,:,2]
        result=np.maximum(result,0)
        result=np.uint8(result)
        return result

    def __IncrementImgNum(self):
        self.ImageCounter+=1
        if(len(self.RawImages)<=self.ImageCounter): self.ImageCounter=0

    def __DecrementImgNum(self):
        self.ImageCounter-=1
        if (0 > self.ImageCounter): self.ImageCounter = len(self.RawImages)-1

    def ButtonBackClick(self):
        self.__DecrementImgNum()
        self.CurrentInput = self.RawImages[self.ImageCounter]
        self.CurrentPrediction = self.__ApplyTransformation(self.RawImages[self.ImageCounter])
        self.CurrentPredictionOnInput = self.__MaskOnImage(self.RawImages[self.ImageCounter], self.CurrentPrediction)
        self.ImCurrentInput = Image.fromarray(self.CurrentInput)
        self.ImCurrentPrediction = Image.fromarray(self.CurrentPrediction)
        self.ImCurrentPredictionOnInput = Image.fromarray(self.CurrentPredictionOnInput)
        self.TKCurrentInput = ImageTk.PhotoImage(Image.fromarray(self.CurrentInput))
        self.TKCurrentPrediction = ImageTk.PhotoImage(Image.fromarray(self.CurrentPrediction))
        self.TKCurrentPredictionOnInput = ImageTk.PhotoImage(Image.fromarray(self.CurrentPredictionOnInput))
        self.canvas1.create_image(20, 20, anchor="nw", image=self.TKCurrentInput)
        self.canvas2.create_image(20, 20, anchor="nw", image=self.TKCurrentPrediction)
        self.canvas3.create_image(20, 20, anchor="nw", image=self.TKCurrentPredictionOnInput)

    def ButtonForwardClick(self):
        self.__IncrementImgNum()
        self.CurrentInput = self.RawImages[self.ImageCounter]
        self.CurrentPrediction=self.__ApplyTransformation(self.RawImages[self.ImageCounter])
        self.CurrentPredictionOnInput = self.__MaskOnImage(self.RawImages[self.ImageCounter], self.CurrentPrediction)
        self.ImCurrentInput = Image.fromarray(self.CurrentInput)
        self.ImCurrentPrediction = Image.fromarray(self.CurrentPrediction)
        self.ImCurrentPredictionOnInput = Image.fromarray(self.CurrentPredictionOnInput)
        self.TKCurrentInput = ImageTk.PhotoImage(Image.fromarray(self.CurrentInput))
        self.TKCurrentPrediction = ImageTk.PhotoImage(Image.fromarray(self.CurrentPrediction))
        self.TKCurrentPredictionOnInput = ImageTk.PhotoImage(Image.fromarray(self.CurrentPredictionOnInput))
        self.canvas1.create_image(20, 20, anchor="nw", image=self.TKCurrentInput)
        self.canvas2.create_image(20, 20, anchor="nw", image=self.TKCurrentPrediction)
        self.canvas3.create_image(20, 20, anchor="nw", image=self.TKCurrentPredictionOnInput)

    def CallPainter(self):
        PaintApplication(self.TKCurrentInput,self.ImCurrentInput,self.TKCurrentPrediction,self.ImCurrentPrediction,
                         self.ImageNames[self.ImageCounter],self.TrainingMaskDirectory)
        root.title('Paint Application')



class PaintApplication:
    def __init__(self, input, im_input, TkImage, ImImage, CurrentImgName, TrainingMaskDirectory):
        self.TrainingMaskDirectory = TrainingMaskDirectory
        self.CurrentImageName = CurrentImgName
        self.input = input #TK image
        self.im_input = im_input #Image image
        self.gif1 = TkImage #TK original label
        self.im_img = copy.copy(ImImage) #Image original label
        self.Im_current_label = copy.copy(ImImage) #Image current label
        self.Tk_current_img = TkImage #TK current label
        self.master = Toplevel()
        self.color_fg = 'white'
        self.im_color_fg = "#ffffff"
        self.color_bg = 'black'
        self.im_color_bg = "#000000"
        self.old_x = None
        self.old_y = None
        self.penwidth = 4
        self.draw = None
        self.drawWidgets()
        self.c.bind('<B1-Motion>', self.paint)
        self.c.bind('<ButtonRelease-1>', self.reset)

    def __MaskOnImage(self, img, mask):
        img = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)
        if np.shape(mask)[2] == 3:
            mask = cv2.cvtColor(mask, cv2.COLOR_RGB2GRAY)
        result = np.zeros_like(img, dtype=np.int16)
        result[:, :, 0] = img[:, :, 0]
        result[:, :, 1] = img[:, :, 1] - mask / 256 * 50
        result[:, :, 2] = img[:, :, 2]
        result = np.maximum(result, 0)
        result = np.uint8(result)
        return result

    def render_label(self):
        self.Tk_current_img = ImageTk.PhotoImage(
            Image.fromarray(self.__MaskOnImage(np.array(self.im_input), np.array(self.Im_current_label))))
        self.c.create_image(0, 0, image=self.Tk_current_img, anchor=NW)

    def paint(self, e):
        if self.old_x and self.old_y:
            self.draw.line([(self.old_x, self.old_y), (e.x, e.y)], fill=self.im_color_fg, width=int(float(self.penwidth)))
            self.render_label()
            #self.c.create_line(self.old_x, self.old_y, e.x, e.y, width=self.penwidth,
            #                   fill=self.color_fg, capstyle=ROUND, smooth=True)
        self.old_x = e.x
        self.old_y = e.y



    def reset(self, e):
        self.old_x = None
        self.old_y = None

    def changew(self, e):
        self.penwidth = e

    def clear(self):
        self.Im_current_label = self.im_img
        self.draw = ImageDraw.Draw(self.Im_current_label)
        self.render_label()

    def change_fg(self):
        self.color_fg = colorchooser.askcolor(color=self.color_fg)[1]

    def eraser(self):
        if (self.var1.get() == 1):
            self.color_fg = 'black'
            self.im_color_fg = "#000000"
        else:
            self.color_fg = 'white'
            self.im_color_fg = "#ffffff"

#    def change_bg(self):
#        self.color_bg = colorchooser.askcolor(color=self.color_bg)[1]

    #def loadImage(self, photoImage):
    #    self.gif1 = photoImage  # a CurrentPrediction kell

    def saveImage(self):
        #x1 = self.c.winfo_rootx()
        #y1 = self.c.winfo_rooty()
        #x2 = x1 + self.c.winfo_width()
        #y2 = y1 + self.c.winfo_height()
        newImageName= self.CurrentImageName.split("g",1)[0] +"g_new_groundtruth"+self.CurrentImageName.split("g",1)[1]
        print(newImageName)
        #ImageGrab.grab().crop((x1, y1, x2, y2)).save(newImageName) #j.save("C:/Users/User/Desktop/mesh_trans",".bmp"), Ã­gy kell kimenteni egy adott helyre
        ##cv2.imwrite(os.path.join("C:\\Users\\Thinkpad\\Desktop\\Python_Project\\verzio1\\",'mit.tif'),self.gif1)
        ##cv2.waitKey(0)
        self.Im_current_label.save(self.TrainingMaskDirectory+newImageName)



    def drawWidgets(self):
        self.controls = Frame(self.master, padx=5, pady=5)
        Label(self.controls, text="Penwidth", font=('arial 16')).grid(row=0, column=0)
        self.var1 = IntVar()
        self.cb = Checkbutton(self.controls, text='Erase', font=('arial 16'), variable=self.var1, onvalue=1, offvalue=0,
                              command=self.eraser).grid(row=5, column=0)
        self.slider = ttk.Scale(self.controls, from_=4, to=15, command=self.changew, orient=HORIZONTAL)
        self.slider.set(self.penwidth)
        self.slider.grid(row=0, column=1, ipadx=30)
        self.controls.pack(side=LEFT)


        self.c = Canvas(self.master, width=self.gif1.width(), height=self.gif1.height(), bg=self.color_bg, ) #itt fontos, hogy a height Ã©s a width a kÃ©phez legyen igazÃ­tva
        ##self.c2 = Canvas(self.master, width=self.gif1.width(), height=self.gif1.height(), bg=self.color_bg, )
        self.c.pack(fill=BOTH, expand=True)
        ##self.c2.pack(fill=BOTH, expand=True)
        self.draw = ImageDraw.Draw(self.Im_current_label)

        self.render_label() #itt tÃ¶ltÃ¶m be az image-et a hÃ¡ttÃ©rre
        ##self.c2.create_image(0, 0, image=self.input, anchor=NW)  # itt tÃ¶ltÃ¶m be az image-et a hÃ¡ttÃ©rre

        menu = Menu(self.master)
        self.master.config(menu=menu)
        optionmenu = Menu(menu)
        menu.add_cascade(label='Options', menu=optionmenu)
        optionmenu.add_command(label='Clear Canvas', command=self.clear)
        optionmenu.add_command(label='Save Image', command=self.saveImage)



##############################

#Loading the data and setting up the Unet
TrainingImageDirectory = 'C:\\Users\\Thinkpad\\Desktop\\Python_Project\\verzio1\\TrainingData\\images\\'
TrainingMaskDirectory = 'C:\\Users\\Thinkpad\\Desktop\\Python_Project\\verzio1\\TrainingData\\masks\\'
UnetWeights50 = 'C:\\Users\\Thinkpad\\Desktop\\Python_Project\\verzio1\\NNVersions\\mitochondria_test_50_epochs.hdf5'
RawDataPath = "C:\\Users\\Thinkpad\\Desktop\\Python_Project\\verzio1\\RawData\\"
Directory="C:\\Users\\Thinkpad\\Desktop\\Python_Project\\verzio1\\"

root = Tk()
ImgViewer1 = ImageViewer(root, TrainingImageDirectory, TrainingMaskDirectory, UnetWeights50, RawDataPath)
root.mainloop()
